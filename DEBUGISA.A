	#TITLE	"DEBUG SUPPORT ISA"
	#SUBTTL	"(C)2020 Lodden Services, LLC"
	#PAGE	132
;
;
	MODULE	"DEBUGISA" 		;MODULE NAME
;
	#INCLUDE "DREQUATE" 		;DRIVER SYMBOLIC EQUIVALENCES
;
	LOC	Code#			;LOCATE IN CODE SEGMENT
;
DEBUGD::PUSHF				;SAVE REGISTERS
	PUSH	AX
	PUSH	BX
	PUSH	DX
	MOV	AH,=0			;CLEAR LEADING ZERO FLAG
	MOV	DX,=10000 		;DISPLAY TEN THOUSANDS DIGIT
	CALL	__DO
	MOV	DX,=1000 		;DISPLAY THOUSANDS DIGIT
	CALL	__DO
	MOV	DX,=100			;DISPLAY HUNDREDS DIGIT
	CALL	__DO
	MOV	DX,=10			;DISPLAY TENS DIGIT
	CALL	__DO
	INC	AH			;INCREMENT LEADING ZERO FLAG
	MOV	DX,=1			;DISPLAY UNITS DIGIT
	CALL	__DO
	POP	DX			;RESTORE REGISTERS
	POP	BX
	POP	AX
	POPF
	CALL	DEBUGM			;DISPLAY "D"
	BYTE	"D",0
	RET
;
__DO:	MOV	AL,=-1			;PRESET QUOTENT
	CLC				;CLEAR CARRY FLAG
__DL:	INC	AL			;INCREMENT QUOTENT
	SUB	BX,DX			;SUBTRACT DIVISOR
	JNC	__DL			;UNTIL UNDERFLOW
;
	ADD	BX,DX			;RESTORE UNDERFLOW
	TEST	AL,AL			;QUOTENT=0?
	JNZ	__DD			;IF NOT, DISPLAY DIGIT
;
	TEST	AH,AH			;LEADING ZERO FLAG SET?
	JZ	__X			;IF NOT, DONE
;
__DD:	ADD	AL,='0'			;ADD ASCII BIAS
	CALL	DEBUGO			;OUTPUT CHARACTER
	INC	AH			;INCREMENT LEADING ZERO FLAG
__X:	RET
;
;print the HEX and BINARY value of reg BX
;
DEBUGBBX::
	PUSH	AX			; save AX
	PUSH	BX			; save a copy of BX
	CALL	DEBUGH			; display the value in Hex
	POP	BX			; recover the saved value
	MOV	AL,BH			; high byte of BX value
	CALL	BPRINT			; print the value in Binary
	MOV	AL,BL			; low byte of BX value
	CALL	PBCHAR
	POP	AX
	RET
;
;display the value in HEX and BINARY from reg AL
;
DEBUGB::PUSH	AX			; save the display character
	CALL	D_HEXO			; display the value in hex
	CALL	D_HEXH			; display the H character
	POP	AX			; recover the display character
PBCHAR:	CALL	BPRINT			; print the value in Binary
	CALL	DEBUGM
	BYTE	"B",0			; binary display
	RET
;
DEBUGH::PUSHF				;SAVE FLAGS
	PUSH	AX			;SAVE AX-REG
	MOV	AL,BH			;GET MSB OF VALUE
	CALL	D_HEXO			;DISPLAY MSB IN HEX
	MOV	AL,BL			;GET LSB OF VALUE
	CALL	D_HEXO			;DISPLAY LSB IN HEX
	POP	AX			;RESTORE AX-REG
	POPF				;RESTORE FLAGS
D_HEXH:	CALL	DEBUGM			;DISPLAY "H"
	BYTE	"H",0
	RET
;
D_HEXO:	PUSH	AX			;SAVE VALUE
	ROR	AL,=1			;SHIFT MSN TO LSN
	ROR	AL,=1
	ROR	AL,=1
	ROR	AL,=1
	CALL	__HEXN			;DISPLAY MSN IN HEX
	POP	AX			;RESTORE VALUE
;
__HEXN:	AND	AL,=0x0F 		;EXTRACT NIBBLE
	ADD	AL,='0'			;ADD ASCII BIAS
	CMP	AL,='9'+1 		;VALID HEX DIGIT?
	JC	DEBUGO			;IF SO, CONTINUE
	ADD	AL,='A'-('9'+1) 	;ELSE, ADD LETTER BIAS
;
;OUTPUT CHARACTER
;
DEBUGO::PUSHF				;SAVE FLAGS
	PUSH	AX			;SAVE AX-REG
	PUSH	BX			;SAVE BX-REG
	PUSH	BP			;SAVE BP-REG
	OUT	0xE9,AL
	POP	BP			;RESTORE BP-REG
	POP	BX			;RESTORE BX-REG
	POP	AX			;RESTORE AX-REG
	POPF				;RESTORE FLAGS
	RET
;
DEBUGM::PUSHF				;SAVE FLAGS
	PUSH	AX			;SAVE AF-REG
	PUSH	BX			;SAVE BX-REG
	PUSH	BP			;SAVE BP-REG
	MOV	BP,SP			;GET STACK POINTER
	MOV	BX,8[BP] 		;GET MESSAGE ADDRESS
;
__L:	CS MOV	AL,[BX]			;ELSE, GET MESSAGE CHARACTER
	INC	BX			;INCREMENT MESSAGE POINTER
	TEST	AL,AL			;LAST CHARACTER OF MESSAGE?
	JZ	__X			;IF SO, CONTINUE
;
	CALL	DEBUGO			;ELSE, OUTPUT CHARACTER
	JMPS	__L			;CONTINUE
;
__X:	MOV	8[BP],BX 		;SET UP RETURN ADDRESS
	POP	BP			;RESTORE BP-REG
	POP	BX			;RESTORE BX-REG
	POP	AX			;RESTORE AX-REG
	POPF				;RESTORE FLAGS
	RET
;
BPRINT:	PUSH	CX			; save counter register value
	CALL	DEBUGM
	BYTE	ASP,ASP,ASP,0		; 3 spaces
	MOV	CX,=8			; only 8 chars to display
	MOV	AH,AL			; get the character
__1:	ROL	AH,=1			; rotate left 1 place
	MOV	AL,='0'			; get an ascii 0
	JNC	__2
	INC	AL			; else display an ascii 1
__2:	CALL	DEBUGO
	LOOP	__1			; loop till all displayed
	POP	CX			; recover CX reg
	RET
;
	END
